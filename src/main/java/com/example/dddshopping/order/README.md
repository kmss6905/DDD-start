배송지 변경 가능 여부를 판단하는 기능이 Order 에 있든, OrderState 에 있든 중요한 덤은
주문과 관련된 중요 업무 규칙을 주문 도메인 모델 Order 나 OrderState 에서 구현한다.

핵심 규칙을 구현한 코드는 도메인 모델에만 위치하기 때문에 규칙이 바뀌거나 규칙을 확장해야 할 때
다른 코드에 영향을 덜 주고 변경내역을 모델에 반영할 수 있게 된다.

도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것이다.
이 과정은 요구 사항에서 출발한다.



도매인 객체가 불완전한 상태로 사용되는 것을 막으려면 생성 시점에 필요한 것을 전달해 주어야한다.
즉, 생성자를 통해 필요한 데이터를 모두 받아야한다.
생성자로 필요한 것을 모두 받으므로 생성자를 호출하는 시점에 필요한 데이터가 올바른지 검사할 수 있다.

### 엔티티와 벨류

엔티티 : 식별자를 갖는다. 식별자는 엔티티 객체마가 고유해서 각 엔티티는 서로 다른 식별자를 갖는다.
가령 주문 도메인에서 각 주문은 주문번호를 갖는데 이 주문번호는 각 주문마다 서로 다르다. 따라다, 주문번호가
식별자가 된다. 주문에서 배송지 주소가 바뀌거나 상태가 바뀌더라도 주문번호가 바뀌지 않는 것 처럼
엔티티의 식별자는 바뀌지 않는다. 엔티티를 생성하고 엔티티의 속성을 바꾸고 엔티티를 삭제할 때까지 식별자는 유지된다.

엔티티의 식별자는 바뀌지 않고 고유하기 때문에 두 엔티티 객체의 식별자가 같으면 두 엔티티는 같다고 판단할 수 있다.

엔티티의 식별자는 바뀌지 않고 고유하기 때문에 두 엔티티 객체의 식별자가 같으면 두 엔티티는 같다고 판단할 수 있다.
엔티티를 구현한 클래스는 equals() 메서드와 hashCode() 메서드를 구현할 수 있다.


### 도메인 용어
코드 작성 시 도메인에서 사용하는 용어는 매우 중요하다. 도메인에서 사용하는 용어를 코드에 반영하지 않으면
그 코드는 개발자에게 코드의 의미를 해석해야 하는 부담을 준다.

알맞은 영단어를 찾는 것은 쉽지 않지만, 시간을 들여 찾는 노력을 해야한다. 한영사전을 사용해서
적당한 단어를 찾는 노력을 하지 않고 도메인에 어울리지 않는 단어를 사용하면 코드는 도메인과 점점 멀어지게 된다.


### 에그리거트
도메인 모델이 복잡해지면 개발자가 전체구조가 아닌 한 개 엔티티와 벨류에만 집중하게 되는 경우가 벌생한다.
이때 상위 수준에서 모델을 관리하기보다 개별 요소에만 초점을 맞추다 보면 큰 수준에서 모델을 이해하지 못해 큰 틀에서 모델을 관리 할 수 없는 상황에 빠질 수 있따.

에그리거트는 독립된 객체 군이며, 각 애그리커트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지않는다.
예를 들어, 주문 애그리거트는 배송지를 변경하거나 주문 상품 개수를 변경하는 등 자기 자신을 관리하지만, 주문 애그리거트에서 회원의 비밀번호를 변경하거나
상품의 가격을 변경하지 않는다.

**경계 설정을 어떻게 할까**
경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다.
모데인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.
예를 들어, 주문할 상품 개수, 배송지 정보, 주문자 정보는 주문 시점에 함께 생성되므로 이들은 한 애그리거트에 속한다.
꼬한 OrderLine의 주문 상품개수를 변경하면 도메인 규칙에 따라 Order의 총 주문 금액을 새로 계산해야 한다. 사용자 요구사항에 따라 주문
상품 개수와 배송지를 함께 변경하기도 한다. 이렇게 **함께 변경되는 빈도가 높은 객체는 한 애그리커트에 속할 가능성이 높다**

흔히 'A가 B를 갖는다.'로 설계할 수 있는 요구사항이 있다면 A와 B를 한 에그리거트로 묶어서 생각하기 쉽다.
가령, 주문의 경우 Order가 ShippingInfo와 Orderer를 가지므로 이는 어느 정도 타당해 보인다. 하지만, 'A 가 B를 갖는다."
로 해석할 수 있는 요구사항이 있다고 하더라도 이것이 반드시 A와 B가 애그리거트에 속한다는 것을 의미 하는 것은 아니다.

좋은 예가 상품과 리뷰다. 상숨 상세 페이지에 들어가면 상품 상세 정보와 함께 리뷰 내용을 보여줘야 한다는 요구사항이 있다면
Product 엔티티와 Review 엔티티가 한 애그리거트에 속한다고 생각할 수 있다. 하지만 Product와 Review는 함께 생성되지 않고 함께
변경되지도 않는다. 게다가 Product를 변경하는 주체가 상품 담당자라면 Review를 생성하고 변경하는 주체는 고객이다.

Review의 변경이 Product 에 영향을 주지 않고 반대로 Product의 변경이 Review에 영향을 주지 않기 때문에
이 둘은 한 애그리거트에 속한다기 보다는 서로 다른 애그리거트에 속한다.
